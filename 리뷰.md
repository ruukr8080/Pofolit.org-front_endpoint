# Pofolit Client 프로젝트 리뷰

## 프로젝트 개요

Pofolit Client는 Next.js 14를 기반으로 한 React 웹 애플리케이션으로, 사용자 인증 및 프로필 관리를 위한 플랫폼입니다. TypeScript를 사용하여 타입 안전성을 확보하고, Redux Toolkit과 RTK Query를 활용한 상태 관리 및 API 통신을 구현했습니다.

### 기술 스택
- **Frontend Framework**: Next.js 14 (App Router)
- **Language**: TypeScript
- **State Management**: Redux Toolkit + RTK Query
- **Styling**: Tailwind CSS
- **Authentication**: OAuth2 (Google, Kakao)
- **Persistence**: redux-persist
- **UI Components**: HTML5 Dialog, Custom Components

### 프로젝트 구조
```
src/
├── app/                    # Next.js App Router
│   ├── layout.tsx         # 글로벌 레이아웃 및 프로바이더
│   ├── page.tsx           # 메인 페이지
│   └── auth/
│       ├── callback/      # OAuth 콜백 처리
│       ├── login/         # 로그인 페이지
│       ├── policy/        # 정책 페이지
│       └── signup/        # 회원가입 페이지
├── components/            # 재사용 가능한 컴포넌트
│   ├── client/           # 클라이언트 컴포넌트
│   ├── server/           # 서버 컴포넌트 (현재 비어있음)
│   └── *.tsx             # 개별 컴포넌트 파일들
├── store/                # Redux 상태 관리
│   ├── store.ts          # 스토어 설정
│   ├── authSlice.ts      # 인증 상태
│   ├── userSlice.ts      # 사용자 상태
│   ├── apiConfig.ts      # RTK Query 설정
│   └── customExceptionHandler.ts # 에러 처리
├── types/                # TypeScript 타입 정의
│   ├── user.ts           # 사용자 관련 타입
│   ├── http.ts           # HTTP 응답 타입
│   └── auth.ts           # 인증 관련 타입
├── hooks/                # 커스텀 훅
│   └── useAuthCookieSync.ts # 쿠키 동기화 훅
└── styles/               # 스타일 파일
    └── globals.css       # 글로벌 스타일
```

## 주요 기능

1. **사용자 인증**: OAuth2를 통한 Google/Kakao 로그인
2. **프로필 관리**: 사용자 정보 표시 및 관리
3. **회원가입**: 추가 정보 입력을 통한 회원가입
4. **에러 처리**: 전역 에러 모달을 통한 사용자 피드백
5. **반응형 UI**: 모바일 친화적인 디자인

## 아키텍처 패턴

- **컴포넌트 기반 아키텍처**: 재사용 가능한 컴포넌트 단위 개발
- **상태 관리**: Redux를 통한 중앙 집중식 상태 관리
- **API 통신**: RTK Query를 통한 선언적 API 호출
- **타입 안전성**: TypeScript를 통한 컴파일 타임 타입 체크
- **모듈화**: 관심사 분리를 통한 유지보수성 향상

## 인증 시스템

### OAuth2 플로우

1. **로그인 시작**: 사용자가 소셜 로그인 버튼 클릭
2. **리디렉션**: OAuth 제공자로 리디렉션 (Google/Kakao)
3. **콜백 처리**: `/auth/callback` 페이지에서 토큰 수신
4. **토큰 저장**: 액세스 토큰을 쿠키에 저장
5. **상태 동기화**: `useAuthCookieSync` 훅을 통해 Redux 상태 업데이트
6. **유저 정보 조회**: RTK Query를 통해 사용자 정보 가져오기

### 주요 컴포넌트

#### SocialLoginButtons
```tsx
// 소셜 로그인 버튼 컴포넌트
const SocialLoginButton: React.FC<SocialLoginButtonProps> = ({
  provider,
  label,
  icon: Icon,
  redirectUrl,
}) => {
  const handleClick = () => {
    window.location.href = redirectUrl; // OAuth 리디렉션
  };
  // ... 스타일링 및 렌더링
};
```

#### UserWidget
```tsx
// 로그인 위젯 컴포넌트
const UserWidget: React.FC<UserWidgetProps> = ({ isOpen, onClose }) => {
  return (
    <dialog open={isOpen}>
      <SocialLoginButtons />
      {/* 로그인 폼 및 버튼들 */}
    </dialog>
  );
};
```

### Redux 상태 관리

#### authSlice.ts
```typescript
const authSlice = createSlice({
  name: 'auth',
  initialState: { isSignedIn: false },
  reducers: {
    setSignState: (state, action) => {
      state.isSignedIn = !!action.payload;
    },
    logout: (state) => {
      state.isSignedIn = false;
    },
  },
});
```

#### userSlice.ts
```typescript
const userSlice = createSlice({
  name: 'user',
  initialState: { user: null },
  reducers: {
    setUserState: (state, action) => {
      state.user = action.payload;
    },
    removeUserInfo: (state) => {
      state.user = null;
    },
  },
});
```

### 쿠키 관리

#### useAuthCookieSync.ts
```typescript
export function useAccessTokenSync() {
  const dispatch = useDispatch();
  useEffect(() => {
    const pre = getCookie("pre"); // 액세스 토큰 쿠키 조회
    if (pre) {
      dispatch(setSignState(pre));
      // 유저 정보 API 호출 (현재 주석 처리됨)
      fetch("/api/v1/users/me", {
        headers: { Authorization: `Bearer ${pre}` },
      })
      .then(res => res.json())
      .then(data => {
        // 유저 정보 저장 로직
      });
    }
  }, [dispatch]);
}
```

### 인증 콜백 처리

#### auth/callback/page.tsx
```tsx
export default function CallbackPage() {
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    
    if (token) {
      // 토큰을 쿠키에 저장
      document.cookie = `pre=${token}; path=/`;
      // 홈페이지로 리디렉션
      router.push('/');
    }
  }, []);
  
  return <LoadingSpinner />;
}
```

## 사용자 관리 시스템

### RTK Query를 활용한 API 통신

#### apiConfig.ts
```typescript
export const userApi = createApi({
  reducerPath: 'userApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/v1',
    prepareHeaders: (headers) => {
      const token = getCookie('pre');
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  endpoints: (builder) => ({
    getUser: builder.query<User, void>({
      query: () => '/users/me',
    }),
  }),
});
```

### 사용자 정보 표시

#### UserProfile 컴포넌트
```tsx
export function UserProfile({ user }: Readonly<{ user: User }>) {
  return (
    <div style={{ display: "flex", flexDirection: "column", alignItems: "center" }}>
      {user.profileImageUrl && (
        <img
          src={user.profileImageUrl}
          alt="프로필 이미지"
          style={{ width: 80, height: 80, borderRadius: 40, marginBottom: 12 }}
        />
      )}
      <p style={{ fontWeight: 700, fontSize: 18 }}>{user.nickname}</p>
    </div>
  );
}
```

#### UserAvatar 컴포넌트
```tsx
export default function UserAvatar({ imageUrl, altText }: UserAvatarProps) {
  return (
    <div className="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center">
      <img
        src={imageUrl}
        alt={altText}
        className="w-full h-full rounded-full"
      />
    </div>
  );
}
```

### 메인 페이지 사용자 정보 표시

#### page.tsx
```tsx
export default function HomePage() {
  const { data: user, isLoading, error } = useGetUserQuery();
  
  if (isLoading) return <LoadingSpinner />;
  if (error) return <div>사용자 정보를 불러올 수 없습니다.</div>;
  
  return (
    <div>
      {user ? (
        <UserProfile user={user} />
      ) : (
        <div>로그인이 필요합니다.</div>
      )}
      <LogoutButton />
    </div>
  );
}
```

### 로그아웃 처리

#### LogoutButton 컴포넌트
```tsx
const LogoutButton: React.FC = () => {
  const router = useRouter();
  const dispatch = useDispatch();

  const handleLogout = () => {
    // 토큰 쿠키 삭제 및 상태 초기화
    dispatch(removeUserInfo());
    router.replace("/");
  };

  return (
    <button onClick={handleLogout}>
      로그아웃
    </button>
  );
};
```

### TypeScript 타입 정의

#### user.ts
```typescript
export interface User {
  id: number;
  email: string;
  nickname: string;
  profileImageUrl?: string;
  role: Role;
  job?: string;
  domain?: string;
}

export enum Role {
  USER = "USER",
  GUEST = "GUEST",
}
```

### 사용자 정보 플로우

1. **페이지 로드**: `useGetUserQuery`를 통해 사용자 정보 조회
2. **로딩 상태**: `LoadingSpinner` 표시
3. **성공**: `UserProfile` 컴포넌트로 사용자 정보 렌더링
4. **에러**: 에러 메시지 표시 또는 로그인 유도
5. **로그아웃**: `removeUserInfo` 액션으로 상태 초기화 및 리디렉션

## 컴포넌트 아키텍처

### 레이아웃 컴포넌트

#### layout.tsx (글로벌 레이아웃)
```tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="ko">
      <body>
        <Provider store={store}>
          <PersistGate loading={<LoadingSpinner />} persistor={persistor}>
            <GlobalErrorModal />
            <Header />
            {children}
            <Footer />
          </PersistGate>
        </Provider>
      </body>
    </html>
  );
}
```

#### Header.tsx (헤더 컴포넌트)
```tsx
export default function Header() {
  const { data: user } = useGetUserQuery();
  
  return (
    <header>
      <div className="flex justify-between items-center">
        <Link href="/">Pofolit</Link>
        <div className="flex items-center gap-4">
          <UserAvatar imageUrl={user?.profileImageUrl} altText={user?.nickname} />
          <UserWidget />
        </div>
      </div>
    </header>
  );
}
```

### 인증 관련 컴포넌트

#### UserWidget.tsx (로그인 위젯)
```tsx
const UserWidget: React.FC<UserWidgetProps> = ({ isOpen, onClose }) => {
  return (
    <dialog open={isOpen} onClose={onClose}>
      <div className="p-6">
        <h2 className="text-xl font-bold mb-4">로그인</h2>
        <SocialLoginButtons />
        <button onClick={onClose} className="mt-4">닫기</button>
      </div>
    </dialog>
  );
};
```

#### SocialLoginButtons.tsx (소셜 로그인 버튼)
```tsx
const SocialLoginButton: React.FC<SocialLoginButtonProps> = ({
  provider,
  label,
  icon: Icon,
  redirectUrl,
}) => {
  const handleClick = () => {
    window.location.href = redirectUrl;
  };

  return (
    <button onClick={handleClick} className="...">
      <Icon className="mr-3" />
      <span>{label}</span>
    </button>
  );
};
```

### 사용자 프로필 컴포넌트

#### UserProfile.tsx
```tsx
export function UserProfile({ user }: Readonly<{ user: User }>) {
  return (
    <div className="flex flex-col items-center">
      {user.profileImageUrl && (
        <img
          src={user.profileImageUrl}
          alt="프로필 이미지"
          className="w-20 h-20 rounded-full mb-3"
        />
      )}
      <p className="font-bold text-lg">{user.nickname}</p>
      <p className="text-gray-600">{user.email}</p>
    </div>
  );
}
```

#### UserAvatar.tsx
```tsx
export default function UserAvatar({ imageUrl, altText }: UserAvatarProps) {
  return (
    <div className="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center">
      <img
        src={imageUrl}
        alt={altText}
        className="w-full h-full rounded-full"
      />
    </div>
  );
}
```

### 폼 컴포넌트

#### SignupForm.tsx (회원가입 폼)
```tsx
export default function SignupForm({
  form,
  handleChange,
  handleSubmit,
  router,
}: SignupFormProps) {
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <input
        type="text"
        name="nickname"
        value={form.nickname}
        onChange={handleChange}
        placeholder="닉네임"
        required
      />
      <select name="job" value={form.job} onChange={handleChange}>
        {JOBS.map(job => (
          <option key={job} value={job}>{job}</option>
        ))}
      </select>
      {/* 기타 필드들 */}
      <button type="submit">회원가입</button>
    </form>
  );
}
```

### 유틸리티 컴포넌트

#### LoadingSpinner.tsx
```tsx
export default function LoadingSpinner({ size = 48, color = "#2563eb" }: LoadingSpinnerProps) {
  return (
    <output aria-label="로딩 중" className="flex items-center justify-center">
      <svg width={size} height={size} viewBox="0 0 50 50">
        <circle
          cx="25" cy="25" r="20"
          fill="none" stroke={color} strokeWidth="5"
          strokeDasharray="31.4 31.4" strokeLinecap="round"
        >
          <animateTransform
            attributeName="transform"
            type="rotate"
            from="0 25 25" to="360 25 25" dur="1s"
            repeatCount="indefinite"
          />
        </circle>
      </svg>
    </output>
  );
}
```

#### Toast.tsx (토스트 알림)
```tsx
export default function Toast({ message, duration = 2500, onClose }: ToastProps) {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false);
      if (onClose) onClose();
    }, duration);
    return () => clearTimeout(timer);
  }, [duration, onClose]);

  if (!visible) return null;

  return (
    <div className="fixed bottom-8 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-6 py-3 rounded-lg shadow-lg z-50">
      {message}
    </div>
  );
}
```

### 에러 처리 컴포넌트

#### ErrorModal.tsx (글로벌 에러 모달)
```tsx
export default function ErrorModal() {
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const handleGlobalError = (event: CustomEvent) => {
      setError(event.detail.message);
    };

    window.addEventListener('globalError', handleGlobalError as EventListener);
    return () => window.removeEventListener('globalError', handleGlobalError as EventListener);
  }, []);

  if (!error) return null;

  return (
    <dialog open className="fixed inset-0 z-50">
      <div className="bg-white p-6 rounded-lg">
        <h3 className="text-lg font-bold mb-4">오류 발생</h3>
        <p>{error}</p>
        <button onClick={() => setError(null)} className="mt-4">닫기</button>
      </div>
    </dialog>
  );
}
```

### 컴포넌트 계층 구조

```
RootLayout
├── GlobalErrorModal
├── Header
│   ├── Logo
│   ├── UserAvatar
│   └── UserWidget
│       └── SocialLoginButtons
├── Main Content
│   ├── HomePage
│   │   ├── UserProfile
│   │   └── LogoutButton
│   ├── Auth Pages
│   │   ├── LoginPage
│   │   ├── SignupPage
│   │   │   └── SignupForm
│   │   ├── CallbackPage
│   │   └── PolicyPage
│   │       └── Policy
└── Footer
```

### 컴포넌트 디자인 패턴

1. **Props 인터페이스**: 각 컴포넌트의 props를 명확히 정의
2. **이벤트 핸들러**: 사용자 상호작용을 위한 이벤트 처리
3. **조건부 렌더링**: 로딩 상태, 에러 상태, 인증 상태에 따른 렌더링
4. **접근성**: ARIA 속성 및 시맨틱 HTML 사용
5. **반응형 디자인**: Tailwind CSS를 활용한 모바일 친화적 디자인

## 에러 처리 시스템

### 전역 에러 처리

#### customExceptionHandler.ts
```typescript
export function handleApiError(error: any): void {
  let message = '알 수 없는 오류가 발생했습니다.';
  
  if (error?.status) {
    switch (error.status) {
      case 400:
        message = '잘못된 요청입니다.';
        break;
      case 401:
        message = '인증이 필요합니다.';
        break;
      case 403:
        message = '접근이 거부되었습니다.';
        break;
      case 404:
        message = '요청한 리소스를 찾을 수 없습니다.';
        break;
      case 500:
        message = '서버 오류가 발생했습니다.';
        break;
      default:
        message = `오류: ${error.status}`;
    }
  }
  
  // 전역 에러 이벤트 발생
  const globalErrorEvent = new CustomEvent('globalError', {
    detail: { message }
  });
  window.dispatchEvent(globalErrorEvent);
}
```

### 글로벌 에러 모달

#### ErrorModal.tsx
```tsx
export default function ErrorModal() {
  const [error, setError] = useState<string | null>(null);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const handleGlobalError = (event: CustomEvent) => {
      setError(event.detail.message);
      setIsVisible(true);
      
      // 5초 후 자동 닫기
      setTimeout(() => {
        setIsVisible(false);
        setError(null);
      }, 5000);
    };

    window.addEventListener('globalError', handleGlobalError as EventListener);
    return () => window.removeEventListener('globalError', handleGlobalError as EventListener);
  }, []);

  if (!isVisible || !error) return null;

  return (
    <dialog open className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="bg-white p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
        <div className="flex items-center mb-4">
          <div className="flex-shrink-0">
            <svg className="h-6 w-6 text-red-500" fill="currentColor" viewBox="0 0 20 20">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
            </svg>
          </div>
          <h3 className="ml-3 text-lg font-medium text-gray-900">오류 발생</h3>
        </div>
        <p className="text-gray-700 mb-4">{error}</p>
        <div className="flex justify-end">
          <button
            onClick={() => {
              setIsVisible(false);
              setError(null);
            }}
            className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
          >
            닫기
          </button>
        </div>
      </div>
    </dialog>
  );
}
```

### RTK Query 에러 처리

#### apiConfig.ts (에러 처리 통합)
```typescript
export const userApi = createApi({
  reducerPath: 'userApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/v1',
    prepareHeaders: (headers) => {
      const token = getCookie('pre');
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  endpoints: (builder) => ({
    getUser: builder.query<User, void>({
      query: () => '/users/me',
      // RTK Query의 transformErrorResponse 활용
      transformErrorResponse: (response) => {
        handleApiError(response);
        return response;
      },
    }),
  }),
});
```

### HTTP 상태 코드 정의

#### http.ts
```typescript
export interface ApiResult<T> {
  success: boolean;
  data?: T;
  error?: {
    code: ExCode;
    message: string;
  };
}

export enum ExCode {
  SUCCESS = 'SUCCESS',
  INVALID_REQUEST = 'INVALID_REQUEST',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  NOT_FOUND = 'NOT_FOUND',
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
}
```

### 컴포넌트 레벨 에러 처리

#### 에러 바운더리 패턴 (권장 사항)
```tsx
class ErrorBoundary extends React.Component {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 에러 로깅
    console.error('Error caught by boundary:', error, errorInfo);
    // 전역 에러 이벤트 발생
    handleApiError({ message: '컴포넌트 오류가 발생했습니다.' });
  }

  render() {
    if (this.state.hasError) {
      return <div>오류가 발생했습니다. 페이지를 새로고침 해주세요.</div>;
    }

    return this.props.children;
  }
}
```

### 에러 처리 플로우

1. **API 호출 실패**: RTK Query에서 에러 발생
2. **에러 변환**: `handleApiError` 함수에서 사용자 친화적 메시지로 변환
3. **전역 이벤트 발생**: `globalError` 커스텀 이벤트 디스패치
4. **모달 표시**: `ErrorModal` 컴포넌트가 이벤트 수신 및 표시
5. **자동 닫기**: 5초 후 자동으로 모달 닫기
6. **수동 닫기**: 사용자가 닫기 버튼으로 모달 닫기

### 에러 처리 전략

- **사용자 경험 우선**: 기술적 에러 메시지 대신 사용자 친화적 메시지 표시
- **비침투성**: 에러가 전체 애플리케이션을 중단시키지 않음
- **자동 복구**: 가능하다면 자동으로 복구 시도
- **로깅**: 개발 환경에서 에러 로깅으로 디버깅 지원
- **타임아웃**: 장시간 로딩 방지를 위한 타임아웃 처리

## 개선 제안 및 최적화

### 1. 보안 강화

#### 현재 문제점
- 쿠키에 액세스 토큰을 평문으로 저장
- 토큰 만료 처리 로직 부재
- HTTPS 강제화 미흡

#### 개선 방안
```typescript
// 보안 쿠키 설정
document.cookie = `accessToken=${token}; path=/; secure; httpOnly; sameSite=strict; max-age=3600`;

// 토큰 만료 확인
const isTokenExpired = (token: string): boolean => {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload.exp * 1000 < Date.now();
  } catch {
    return true;
  }
};

// 자동 토큰 갱신
const refreshTokenIfNeeded = async () => {
  const token = getCookie('accessToken');
  if (token && isTokenExpired(token)) {
    const newToken = await refreshAccessToken();
    if (newToken) {
      document.cookie = `accessToken=${newToken}; ...`;
    }
  }
};
```

### 2. 상태 관리 최적화

#### 현재 문제점
- `useAuthCookieSync`에서 유저 정보 저장이 주석 처리됨
- 불필요한 리렌더링 가능성
- 상태 동기화 타이밍 이슈

#### 개선 방안
```typescript
// useAuthCookieSync.ts 개선
export function useAccessTokenSync() {
  const dispatch = useDispatch();
  
  useEffect(() => {
    const token = getCookie("accessToken");
    if (token && !isTokenExpired(token)) {
      dispatch(setSignState(true));
      
      // 유저 정보 조회 및 저장
      dispatch(fetchUser.initiate()).then((result) => {
        if (result.data) {
          dispatch(setUserState(result.data));
        }
      });
    } else {
      // 토큰이 없거나 만료된 경우
      dispatch(setSignState(false));
      dispatch(removeUserInfo());
    }
  }, [dispatch]);
}
```

### 3. API 통신 개선

#### 현재 문제점
- RTK Query의 캐싱 기능 미활용
- 에러 처리의 일관성 부족
- 로딩 상태 관리 미흡

#### 개선 방안
```typescript
// apiConfig.ts 개선
export const userApi = createApi({
  reducerPath: 'userApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/v1',
    prepareHeaders: (headers, { getState }) => {
      const token = (getState() as RootState).auth.token;
      if (token) {
        headers.set('Authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['User'],
  endpoints: (builder) => ({
    getUser: builder.query<User, void>({
      query: () => '/users/me',
      providesTags: ['User'],
      // 캐시 무효화 및 재시도 로직
      keepUnusedDataFor: 300, // 5분 캐시
      extraOptions: {
        maxRetries: 3,
      },
    }),
    updateUser: builder.mutation<User, Partial<User>>({
      query: (userData) => ({
        url: '/users/me',
        method: 'PUT',
        body: userData,
      }),
      invalidatesTags: ['User'],
    }),
  }),
});
```

### 4. 컴포넌트 최적화

#### 현재 문제점
- 불필요한 리렌더링
- 메모이제이션 부족
- 컴포넌트 분리 미흡

#### 개선 방안
```tsx
// UserProfile 컴포넌트 최적화
const UserProfile = memo(({ user }: { user: User }) => {
  return (
    <div className="flex flex-col items-center">
      {user.profileImageUrl && (
        <img
          src={user.profileImageUrl}
          alt="프로필 이미지"
          className="w-20 h-20 rounded-full mb-3"
          loading="lazy"
        />
      )}
      <p className="font-bold text-lg">{user.nickname}</p>
      <p className="text-gray-600">{user.email}</p>
    </div>
  );
});

// 커스텀 훅으로 로직 분리
const useUserProfile = () => {
  const { data: user, isLoading, error } = useGetUserQuery();
  const dispatch = useDispatch();
  
  const handleLogout = useCallback(() => {
    dispatch(logout());
    // 쿠키 정리 등 추가 로직
  }, [dispatch]);
  
  return { user, isLoading, error, handleLogout };
};
```

### 5. 사용자 경험 개선

#### 현재 문제점
- 로딩 상태 표시 부족
- 에러 메시지 일관성 부족
- 접근성 고려 미흡

#### 개선 방안
```tsx
// Suspense와 Error Boundary 활용
const UserProfileWrapper = () => (
  <ErrorBoundary fallback={<div>사용자 정보를 불러올 수 없습니다.</div>}>
    <Suspense fallback={<LoadingSpinner />}>
      <UserProfile />
    </Suspense>
  </ErrorBoundary>
);

// 접근성 개선
const SocialLoginButton = ({ provider, label, icon: Icon, redirectUrl }: Props) => (
  <button
    onClick={() => window.location.href = redirectUrl}
    aria-label={`${provider}로 ${label}`}
    className="..."
  >
    <Icon aria-hidden="true" />
    <span>{label}</span>
  </button>
);
```

### 6. 개발 경험 개선

#### 현재 문제점
- 타입 정의 불완전
- 테스트 코드 부재
- 코드 중복

#### 개선 방안
```typescript
// 타입 정의 강화
interface AuthState {
  isSignedIn: boolean;
  token: string | null;
  user: User | null;
  loading: boolean;
  error: string | null;
}

// 테스트 코드 추가 예시
describe('authSlice', () => {
  it('should handle login', () => {
    const action = setSignState(true);
    const state = authReducer(initialState, action);
    expect(state.isSignedIn).toBe(true);
  });
});
```

### 7. 성능 최적화

#### 권장 사항
- **코드 스플리팅**: 라우트 기반 코드 분할
- **이미지 최적화**: Next.js Image 컴포넌트 활용
- **번들 분석**: webpack-bundle-analyzer로 번들 크기 분석
- **PWA**: 서비스 워커로 오프라인 지원

### 8. 모니터링 및 로깅

#### 구현 제안
```typescript
// 에러 로깅 서비스
const logError = (error: Error, context?: any) => {
  if (process.env.NODE_ENV === 'production') {
    // 외부 로깅 서비스로 전송
    console.error('Error logged:', { error, context, timestamp: new Date() });
  }
};

// 사용자 행동 추적
const trackEvent = (eventName: string, properties?: Record<string, any>) => {
  // 분석 서비스로 전송
  console.log('Event tracked:', { eventName, properties });
};
```

### 결론

현재 프로젝트는 기본적인 인증 및 사용자 관리 기능을 잘 구현하고 있지만, 보안, 성능, 사용자 경험 측면에서 개선의 여지가 있습니다. 위에서 제안한 개선사항들을 단계적으로 적용한다면 더욱 견고하고 사용자 친화적인 애플리케이션이 될 것입니다.