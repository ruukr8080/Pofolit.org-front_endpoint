# Pofolit Client 프로젝트 리뷰

## 프로젝트 개요

Pofolit Client는 Next.js 14를 기반으로 한 React 웹 애플리케이션으로, 사용자 인증 및 프로필 관리를 위한 플랫폼입니다. TypeScript를 사용하여 타입 안전성을 확보하고, Redux Toolkit과 RTK Query를 활용한 상태 관리 및 API 통신을 구현했습니다.

### 기술 스택

- **Frontend Framework**: Next.js 14 (App Router)
- **Language**: TypeScript
- **State Management**: Redux Toolkit + RTK Query
- **Styling**: Tailwind CSS
- **Authentication**: OAuth2 (Google, Kakao)
- **Persistence**: redux-persist
- **UI Components**: HTML5 Dialog, Custom Components

보안 및 , oauth2/jwt 관련 된 기능은 백엔드(스프링)에서 대부분 처리합니다.

### 프로젝트 구조

```
src/
├── app/                    # Next.js App Router
│   ├── layout.tsx         # 글로벌 레이아웃 및 프로바이더
│   ├── page.tsx           # 메인 페이지
│   └── auth/
│       ├── callback/      # OAuth 콜백 처리
│       ├── login/         # 로그인 페이지
│       ├── policy/        # 정책 페이지
│       └── signup/        # 회원가입 페이지
├── components/            # 재사용 가능한 컴포넌트
│   ├── client/           # 클라이언트 컴포넌트
│   ├── server/           # 서버 컴포넌트 (현재 비어있음)
│   └── *.tsx             # 개별 컴포넌트 파일들
├── store/                # Redux 상태 관리
│   ├── store.ts          # 스토어 설정
│   ├── authSlice.ts      # 인증 상태
│   ├── userSlice.ts      # 사용자 상태
│   ├── apiConfig.ts      # RTK Query 설정
│   └── customExceptionHandler.ts # 에러 처리
├── types/                # TypeScript 타입 정의
│   ├── user.ts           # 사용자 관련 타입
│   ├── http.ts           # HTTP 응답 타입
│   └── auth.ts           # 인증 관련 타입
├── hooks/                # 커스텀 훅
│   └── useAuthCookieSync.ts # 쿠키 동기화 훅
└── styles/               # 스타일 파일
    └── globals.css       # 글로벌 스타일
```

## 주요 기능

1. **사용자 인증**: OAuth2를 통한 Google/Kakao 로그인
2. **프로필 관리**: 사용자 정보 표시 및 관리
3. **회원가입**: 추가 정보 입력을 통한 회원가입
4. **에러 처리**: 전역 에러 모달을 통한 사용자 피드백
5. **반응형 UI**: 모바일 친화적인 디자인

## 아키텍처 패턴

- **컴포넌트 기반 아키텍처**: 재사용 가능한 컴포넌트 단위 개발
- **상태 관리**: Redux를 통한 중앙 집중식 상태 관리
- **API 통신**: RTK Query를 통한 선언적 API 호출
- **타입 안전성**: TypeScript를 통한 컴파일 타임 타입 체크
- **모듈화**: 관심사 분리를 통한 유지보수성 향상

## 인증 시스템

### OAuth2 플로우

1. **로그인 시작**: 사용자가 소셜 로그인 버튼 클릭
2. **리디렉션**: OAuth 제공자로 리디렉션 (Google/Kakao)
3. **콜백 처리**: `/auth/callback` 페이지에서 토큰 수신
4. **토큰 저장**: 액세스 토큰을 쿠키에 저장
5. **상태 동기화**: `useAuthCookieSync` 훅을 통해 Redux 상태 업데이트
6. **유저 정보 조회**: RTK Query를 통해 사용자 정보 가져오기

### 주요 컴포넌트

#### SocialLoginButtons

```tsx
// 소셜 로그인 버튼 컴포넌트
const SocialLoginButton: React.FC<SocialLoginButtonProps> = ({
  provider,
  label,
  icon: Icon,
  redirectUrl,
}) => {
  const handleClick = () => {
    window.location.href = redirectUrl; // OAuth 리디렉션
  };
  // ... 스타일링 및 렌더링
};
```

#### UserWidget

```tsx
// 로그인 위젯 컴포넌트
const UserWidget: React.FC<UserWidgetProps> = ({ isOpen, onClose }) => {
  return (
    <dialog open={isOpen}>
      <SocialLoginButtons />
      {/* 로그인 폼 및 버튼들 */}
    </dialog>
  );
};
```

### Redux 상태 관리

#### authSlice.ts

```typescript
const authSlice = createSlice({
  name: "auth",
  initialState: { isSignedIn: false },
  reducers: {
    setSignState: (state, action) => {
      state.isSignedIn = !!action.payload;
    },
    logout: (state) => {
      state.isSignedIn = false;
    },
  },
});
```

#### userSlice.ts

```typescript
const userSlice = createSlice({
  name: "user",
  initialState: { user: null },
  reducers: {
    setUserState: (state, action) => {
      state.user = action.payload;
    },
    removeUserInfo: (state) => {
      state.user = null;
    },
  },
});
```

### 쿠키 관리

#### useAuthCookieSync.ts

```typescript
export function useAccessTokenSync() {
  const dispatch = useDispatch();
  useEffect(() => {
    const pre = getCookie("pre"); // 액세스 토큰 쿠키 조회
    if (pre) {
      dispatch(setSignState(pre));
      // 유저 정보 API 호출 (현재 주석 처리됨)
      fetch("/api/v1/users/me", {
        headers: { Authorization: `Bearer ${pre}` },
      })
        .then((res) => res.json())
        .then((data) => {
          // 유저 정보 저장 로직
        });
    }
  }, [dispatch]);
}
```

### 인증 콜백 처리

#### auth/callback/page.tsx

```tsx
export default function CallbackPage() {
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get("token");

    if (token) {
      // 토큰을 쿠키에 저장
      document.cookie = `pre=${token}; path=/`;
      // 홈페이지로 리디렉션
      router.push("/");
    }
  }, []);

  return <LoadingSpinner />;
}
```

## 사용자 관리 시스템

### RTK Query를 활용한 API 통신

#### apiConfig.ts

```typescript
export const userApi = createApi({
  reducerPath: "userApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api/v1",
    prepareHeaders: (headers) => {
      const token = getCookie("pre");
      if (token) {
        headers.set("Authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  endpoints: (builder) => ({
    getUser: builder.query<User, void>({
      query: () => "/users/me",
    }),
  }),
});
```

### 사용자 정보 표시

#### UserProfile 컴포넌트

```tsx
export function UserProfile({ user }: Readonly<{ user: User }>) {
  return (
    <div
      style={{ display: "flex", flexDirection: "column", alignItems: "center" }}
    >
      {user.profileImageUrl && (
        <img
          src={user.profileImageUrl}
          alt="프로필 이미지"
          style={{ width: 80, height: 80, borderRadius: 40, marginBottom: 12 }}
        />
      )}
      <p style={{ fontWeight: 700, fontSize: 18 }}>{user.nickname}</p>
    </div>
  );
}
```

#### UserAvatar 컴포넌트

```tsx
export default function UserAvatar({ imageUrl, altText }: UserAvatarProps) {
  return (
    <div className="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center">
      <img
        src={imageUrl}
        alt={altText}
        className="w-full h-full rounded-full"
      />
    </div>
  );
}
```

### 메인 페이지 사용자 정보 표시

#### page.tsx

```tsx
export default function HomePage() {
  const { data: user, isLoading, error } = useGetUserQuery();

  if (isLoading) return <LoadingSpinner />;
  if (error) return <div>사용자 정보를 불러올 수 없습니다.</div>;

  return (
    <div>
      {user ? <UserProfile user={user} /> : <div>로그인이 필요합니다.</div>}
      <LogoutButton />
    </div>
  );
}
```

### 로그아웃 처리

#### LogoutButton 컴포넌트

```tsx
const LogoutButton: React.FC = () => {
  const router = useRouter();
  const dispatch = useDispatch();

  const handleLogout = () => {
    // 토큰 쿠키 삭제 및 상태 초기화
    dispatch(removeUserInfo());
    router.replace("/");
  };

  return <button onClick={handleLogout}>로그아웃</button>;
};
```

### TypeScript 타입 정의

#### user.ts

```typescript
export interface User {
  id: number;
  email: string;
  nickname: string;
  profileImageUrl?: string;
  role: Role;
  job?: string;
  domain?: string;
}

export enum Role {
  USER = "USER",
  GUEST = "GUEST",
}
```

### 사용자 정보 플로우

1. **페이지 로드**: `useGetUserQuery`를 통해 사용자 정보 조회
2. **로딩 상태**: `LoadingSpinner` 표시
3. **성공**: `UserProfile` 컴포넌트로 사용자 정보 렌더링
4. **에러**: 에러 메시지 표시 또는 로그인 유도
5. **로그아웃**: `removeUserInfo` 액션으로 상태 초기화 및 리디렉션

## 컴포넌트 아키텍처

### 레이아웃 컴포넌트

#### layout.tsx (글로벌 레이아웃)

```tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body>
        <Provider store={store}>
          <PersistGate loading={<LoadingSpinner />} persistor={persistor}>
            <GlobalErrorModal />
            <Header />
            {children}
            <Footer />
          </PersistGate>
        </Provider>
      </body>
    </html>
  );
}
```

#### Header.tsx (헤더 컴포넌트)

```tsx
export default function Header() {
  const { data: user } = useGetUserQuery();

  return (
    <header>
      <div className="flex justify-between items-center">
        <Link href="/">Pofolit</Link>
        <div className="flex items-center gap-4">
          <UserAvatar
            imageUrl={user?.profileImageUrl}
            altText={user?.nickname}
          />
          <UserWidget />
        </div>
      </div>
    </header>
  );
}
```

### 인증 관련 컴포넌트

#### UserWidget.tsx (로그인 위젯)

```tsx
const UserWidget: React.FC<UserWidgetProps> = ({ isOpen, onClose }) => {
  return (
    <dialog open={isOpen} onClose={onClose}>
      <div className="p-6">
        <h2 className="text-xl font-bold mb-4">로그인</h2>
        <SocialLoginButtons />
        <button onClick={onClose} className="mt-4">
          닫기
        </button>
      </div>
    </dialog>
  );
};
```

#### SocialLoginButtons.tsx (소셜 로그인 버튼)

```tsx
const SocialLoginButton: React.FC<SocialLoginButtonProps> = ({
  provider,
  label,
  icon: Icon,
  redirectUrl,
}) => {
  const handleClick = () => {
    window.location.href = redirectUrl;
  };

  return (
    <button onClick={handleClick} className="...">
      <Icon className="mr-3" />
      <span>{label}</span>
    </button>
  );
};
```

### 사용자 프로필 컴포넌트

#### UserProfile.tsx

```tsx
export function UserProfile({ user }: Readonly<{ user: User }>) {
  return (
    <div className="flex flex-col items-center">
      {user.profileImageUrl && (
        <img
          src={user.profileImageUrl}
          alt="프로필 이미지"
          className="w-20 h-20 rounded-full mb-3"
        />
      )}
      <p className="font-bold text-lg">{user.nickname}</p>
      <p className="text-gray-600">{user.email}</p>
    </div>
  );
}
```

#### UserAvatar.tsx

```tsx
export default function UserAvatar({ imageUrl, altText }: UserAvatarProps) {
  return (
    <div className="w-8 h-8 rounded-full bg-gray-300 flex items-center justify-center">
      <img
        src={imageUrl}
        alt={altText}
        className="w-full h-full rounded-full"
      />
    </div>
  );
}
```

### 폼 컴포넌트

#### SignupForm.tsx (회원가입 폼)

```tsx
export default function SignupForm({
  form,
  handleChange,
  handleSubmit,
  router,
}: SignupFormProps) {
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <input
        type="text"
        name="nickname"
        value={form.nickname}
        onChange={handleChange}
        placeholder="닉네임"
        required
      />
      <select name="job" value={form.job} onChange={handleChange}>
        {JOBS.map((job) => (
          <option key={job} value={job}>
            {job}
          </option>
        ))}
      </select>
      {/* 기타 필드들 */}
      <button type="submit">회원가입</button>
    </form>
  );
}
```

### 유틸리티 컴포넌트

#### LoadingSpinner.tsx

```tsx
export default function LoadingSpinner({
  size = 48,
  color = "#2563eb",
}: LoadingSpinnerProps) {
  return (
    <output aria-label="로딩 중" className="flex items-center justify-center">
      <svg width={size} height={size} viewBox="0 0 50 50">
        <circle
          cx="25"
          cy="25"
          r="20"
          fill="none"
          stroke={color}
          strokeWidth="5"
          strokeDasharray="31.4 31.4"
          strokeLinecap="round"
        >
          <animateTransform
            attributeName="transform"
            type="rotate"
            from="0 25 25"
            to="360 25 25"
            dur="1s"
            repeatCount="indefinite"
          />
        </circle>
      </svg>
    </output>
  );
}
```

#### Toast.tsx (토스트 알림)

```tsx
export default function Toast({
  message,
  duration = 2500,
  onClose,
}: ToastProps) {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(false);
      if (onClose) onClose();
    }, duration);
    return () => clearTimeout(timer);
  }, [duration, onClose]);

  if (!visible) return null;

  return (
    <div className="fixed bottom-8 left-1/2 -translate-x-1/2 bg-blue-600 text-white px-6 py-3 rounded-lg shadow-lg z-50">
      {message}
    </div>
  );
}
```

### 에러 처리 컴포넌트

#### ErrorModal.tsx (글로벌 에러 모달)

```tsx
export default function ErrorModal() {
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const handleGlobalError = (event: CustomEvent) => {
      setError(event.detail.message);
    };

    window.addEventListener("globalError", handleGlobalError as EventListener);
    return () =>
      window.removeEventListener(
        "globalError",
        handleGlobalError as EventListener
      );
  }, []);

  if (!error) return null;

  return (
    <dialog open className="fixed inset-0 z-50">
      <div className="bg-white p-6 rounded-lg">
        <h3 className="text-lg font-bold mb-4">오류 발생</h3>
        <p>{error}</p>
        <button onClick={() => setError(null)} className="mt-4">
          닫기
        </button>
      </div>
    </dialog>
  );
}
```

### 컴포넌트 계층 구조

```
RootLayout
├── GlobalErrorModal
├── Header
│   ├── Logo
│   ├── UserAvatar
│   └── UserWidget
│       └── SocialLoginButtons
├── Main Content
│   ├── HomePage
│   │   ├── UserProfile
│   │   └── LogoutButton
│   ├── Auth Pages
│   │   ├── LoginPage
│   │   ├── SignupPage
│   │   │   └── SignupForm
│   │   ├── CallbackPage
│   │   └── PolicyPage
│   │       └── Policy
└── Footer
```

### 컴포넌트 디자인 패턴

1. **Props 인터페이스**: 각 컴포넌트의 props를 명확히 정의
2. **이벤트 핸들러**: 사용자 상호작용을 위한 이벤트 처리
3. **조건부 렌더링**: 로딩 상태, 에러 상태, 인증 상태에 따른 렌더링
4. **접근성**: ARIA 속성 및 시맨틱 HTML 사용
5. **반응형 디자인**: Tailwind CSS를 활용한 모바일 친화적 디자인

## 에러 처리 시스템

### 전역 에러 처리

#### customExceptionHandler.ts

```typescript
export function handleApiError(error: any): void {
  let message = "알 수 없는 오류가 발생했습니다.";

  if (error?.status) {
    switch (error.status) {
      case 400:
        message = "잘못된 요청입니다.";
        break;
      case 401:
        message = "인증이 필요합니다.";
        break;
      case 403:
        message = "접근이 거부되었습니다.";
        break;
      case 404:
        message = "요청한 리소스를 찾을 수 없습니다.";
        break;
      case 500:
        message = "서버 오류가 발생했습니다.";
        break;
      default:
        message = `오류: ${error.status}`;
    }
  }

  // 전역 에러 이벤트 발생
  const globalErrorEvent = new CustomEvent("globalError", {
    detail: { message },
  });
  window.dispatchEvent(globalErrorEvent);
}
```

### 글로벌 에러 모달

#### ErrorModal.tsx

```tsx
export default function ErrorModal() {
  const [error, setError] = useState<string | null>(null);
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const handleGlobalError = (event: CustomEvent) => {
      setError(event.detail.message);
      setIsVisible(true);

      // 5초 후 자동 닫기
      setTimeout(() => {
        setIsVisible(false);
        setError(null);
      }, 5000);
    };

    window.addEventListener("globalError", handleGlobalError as EventListener);
    return () =>
      window.removeEventListener(
        "globalError",
        handleGlobalError as EventListener
      );
  }, []);

  if (!isVisible || !error) return null;

  return (
    <dialog
      open
      className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
    >
      <div className="bg-white p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
        <div className="flex items-center mb-4">
          <div className="flex-shrink-0">
            <svg
              className="h-6 w-6 text-red-500"
              fill="currentColor"
              viewBox="0 0 20 20"
            >
              <path
                fillRule="evenodd"
                d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                clipRule="evenodd"
              />
            </svg>
          </div>
          <h3 className="ml-3 text-lg font-medium text-gray-900">오류 발생</h3>
        </div>
        <p className="text-gray-700 mb-4">{error}</p>
        <div className="flex justify-end">
          <button
            onClick={() => {
              setIsVisible(false);
              setError(null);
            }}
            className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors"
          >
            닫기
          </button>
        </div>
      </div>
    </dialog>
  );
}
```

### RTK Query 에러 처리

#### apiConfig.ts (에러 처리 통합)

```typescript
export const userApi = createApi({
  reducerPath: "userApi",
  baseQuery: fetchBaseQuery({
    baseUrl: "/api/v1",
    prepareHeaders: (headers) => {
      const token = getCookie("pre");
      if (token) {
        headers.set("Authorization", `Bearer ${token}`);
      }
      return headers;
    },
  }),
  endpoints: (builder) => ({
    getUser: builder.query<User, void>({
      query: () => "/users/me",
      // RTK Query의 transformErrorResponse 활용
      transformErrorResponse: (response) => {
        handleApiError(response);
        return response;
      },
    }),
  }),
});
```

### HTTP 상태 코드 정의

#### http.ts

```typescript
export interface ApiResult<T> {
  success: boolean;
  data?: T;
  error?: {
    code: ExCode;
    message: string;
  };
}

export enum ExCode {
  SUCCESS = "SUCCESS",
  INVALID_REQUEST = "INVALID_REQUEST",
  UNAUTHORIZED = "UNAUTHORIZED",
  FORBIDDEN = "FORBIDDEN",
  NOT_FOUND = "NOT_FOUND",
  INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR",
  NETWORK_ERROR = "NETWORK_ERROR",
}
```

### 컴포넌트 레벨 에러 처리

#### 에러 바운더리 패턴 (권장 사항)

```tsx
class ErrorBoundary extends React.Component {
  constructor(props: any) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // 에러 로깅
    console.error("Error caught by boundary:", error, errorInfo);
    // 전역 에러 이벤트 발생
    handleApiError({ message: "컴포넌트 오류가 발생했습니다." });
  }

  render() {
    if (this.state.hasError) {
      return <div>오류가 발생했습니다. 페이지를 새로고침 해주세요.</div>;
    }

    return this.props.children;
  }
}
```

### 에러 처리 플로우

1. **API 호출 실패**: RTK Query에서 에러 발생
2. **에러 변환**: `handleApiError` 함수에서 사용자 친화적 메시지로 변환
3. **전역 이벤트 발생**: `globalError` 커스텀 이벤트 디스패치
4. **모달 표시**: `ErrorModal` 컴포넌트가 이벤트 수신 및 표시
5. **자동 닫기**: 5초 후 자동으로 모달 닫기
6. **수동 닫기**: 사용자가 닫기 버튼으로 모달 닫기

### 에러 처리 전략

- **사용자 경험 우선**: 기술적 에러 메시지 대신 사용자 친화적 메시지 표시
- **비침투성**: 에러가 전체 애플리케이션을 중단시키지 않음
- **자동 복구**: 가능하다면 자동으로 복구 시도
- **로깅**: 개발 환경에서 에러 로깅으로 디버깅 지원
- **타임아웃**: 장시간 로딩 방지를 위한 타임아웃 처리

## 개선 제안 및 최적화

### ✅ 완료된 개선사항

#### 1. 보안 강화 ✅

- 보안 쿠키 설정 (secure, samesite=strict)
- JWT 토큰 만료 자동 검증 및 처리
- 액세스 토큰 자동 갱신 로직

#### 2. 상태 관리 최적화 ✅

- useAuthCookieSync 훅에서 유저 정보 저장 활성화
- Redux 상태 동기화 개선
- 토큰 만료 시 자동 로그아웃

#### 3. API 통신 개선 ✅

- RTK Query 캐싱 및 태그 관리 구현
- 재시도 로직 및 에러 처리 강화
- prepareHeaders를 통한 자동 토큰 포함

#### 4. 컴포넌트 최적화 ✅

- React.memo를 활용한 메모이제이션
- Next.js Image 컴포넌트로 이미지 최적화
- 커스텀 훅으로 비즈니스 로직 분리

#### 5. 사용자 경험 개선 ✅

- Suspense를 통한 비동기 컴포넌트 로딩
- 접근성 속성 (ARIA 레이블) 추가
- 키보드 네비게이션 지원

#### 8. 모니터링 및 로깅 ✅

- 구조화된 에러 로깅 시스템 구현
- 로컬 스토리지 기반 디버깅 지원
- 환경별 로깅 분리 (개발/프로덕션)

### 🚀 앞으로의 개발 Task

#### 6. 개발 경험 개선

##### 단기 Task (1-2주)

- **타입 정의 강화**: 현재 타입들을 더 엄격하게 정의

  ```typescript
  // 목표: 모든 API 응답에 대한 엄격한 타입 정의
  interface ApiResponse<T> {
    success: boolean;
    data: T;
    error?: ApiError;
    timestamp: string;
  }
  ```

- **단위 테스트 추가**: 주요 컴포넌트 및 훅에 대한 테스트 코드 작성

  ```typescript
  // Jest + React Testing Library 활용
  describe("UserProfile", () => {
    it("renders user information correctly", () => {
      // 테스트 케이스 구현
    });
  });
  ```

- **스토리북 도입**: 컴포넌트 개발 및 문서화
  ```bash
  npx storybook init
  ```

##### 중기 Task (1개월)

- **E2E 테스트**: Playwright 또는 Cypress로 종단간 테스트
- **코드 품질 도구**: ESLint 규칙 강화, Prettier 설정
- **개발 서버 최적화**: HMR 개선, 번들 분석

#### 7. 성능 최적화

##### 단기 Task (1-2주)

- **코드 스플리팅**: 라우트 기반 코드 분할

  ```typescript
  // Next.js dynamic import 활용
  const UserProfile = dynamic(() => import("@/components/UserProfile"), {
    loading: () => <LoadingSpinner />,
  });
  ```

- **번들 최적화**: webpack-bundle-analyzer로 분석 및 최적화

  ```bash
  npm install --save-dev webpack-bundle-analyzer
  ```

- **이미지 최적화**: WebP 포맷 지원, lazy loading 강화

##### 중기 Task (1개월)

- **PWA 기능**: 서비스 워커 구현으로 오프라인 지원

  ```typescript
  // next-pwa 패키지 활용
  const withPWA = require("next-pwa")({
    dest: "public",
  });
  ```

- **캐싱 전략**: HTTP 캐시 헤더 최적화
- **CDN 설정**: 정적 자원 CDN 배포

#### 9. 배포 및 인프라

##### 단기 Task (1-2주)

- **CI/CD 파이프라인**: GitHub Actions 설정

  ```yaml
  # .github/workflows/deploy.yml
  name: Deploy to Production
  on:
    push:
      branches: [main]
  jobs:
    deploy:
      # 배포 작업 정의
  ```

- **환경별 설정**: 개발/스테이징/프로덕션 환경 분리
- **모니터링 설정**: 애플리케이션 성능 모니터링 (ex: Vercel Analytics)

##### 중기 Task (1개월)

- **컨테이너화**: Docker 이미지 생성 및 배포
- **스케일링**: 로드 밸런싱 및 캐싱 레이어 추가
- **보안 스캔**: 정기적인 보안 취약점 스캔

#### 10. 사용자 경험 및 접근성

##### 단기 Task (1-2주)

- **다크 모드**: 사용자 선호도에 따른 테마 전환
- **반응형 디자인 강화**: 모바일 우선 접근
- **로딩 상태 개선**: Skeleton UI 구현

##### 중기 Task (1개월)

- **국제화 (i18n)**: 다국어 지원

  ```typescript
  // next-i18next 활용
  import { useTranslation } from "next-i18next";
  ```

- **접근성 감사**: WCAG 2.1 AA 준수 검토
- **사용자 피드백 시스템**: 인앱 피드백 수집

#### 11. 비즈니스 로직 확장

##### 중기 Task (1-2개월)

- **사용자 프로필 관리**: 프로필 편집 기능
- **알림 시스템**: 푸시 알림 및 인앱 알림
- **소셜 기능**: 친구 추가, 팔로우 기능
- **콘텐츠 관리**: 게시물 작성 및 관리

#### 12. 데이터 분석 및 모니터링

##### 중기 Task (1개월)

- **사용자 행동 추적**: Google Analytics 4 또는 Mixpanel 연동
- **에러 모니터링**: Sentry 또는 LogRocket 연동
- **성능 모니터링**: Core Web Vitals 추적
- **A/B 테스트**: 기능별 사용자 반응 분석

### 📋 우선순위별 Task 목록

#### 🔥 긴급 (이번 주)

1. 단위 테스트 추가 (UserProfile, useAuthCookieSync)
2. ESLint 규칙 강화 및 코드 품질 개선
3. CI/CD 파이프라인 기본 설정

#### 📅 단기 (2-4주)

1. 코드 스플리팅 구현
2. PWA 기본 기능 추가
3. 다크 모드 구현
4. 반응형 디자인 개선

#### 📆 중기 (1-3개월)

1. E2E 테스트 구현
2. 국제화 지원
3. 성능 모니터링 시스템 구축
4. 사용자 피드백 시스템 개발

#### 🎯 장기 (3-6개월)

1. 비즈니스 로직 확장 (프로필 관리, 알림 등)
2. 데이터 분석 시스템 구축
3. 모바일 앱 개발 (React Native)
4. AI/ML 기능 통합

### 결론

기본적인 보안, 성능, 사용자 경험 개선은 완료되었습니다. 앞으로는 개발 생산성 향상, 사용자 경험 개선, 비즈니스 로직 확장을 중점적으로 진행할 계획입니다. 각 Task는 현재 프로젝트의 상태와 우선순위를 고려하여 순차적으로 진행될 것입니다.
